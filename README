WebSocketServer
Written for Python 2.7

Kevin Cuzner

This is a server meant to run dedicated on a specific port on the host machine.
It provides a method to host multiple WebSocket-based services sorted by
directory and provide a (relatively) easy interface for writing additional
services. This server utilizes the threading library instead of the
multiprocessing library and thus will only ever use one full core on the CPU.
However, seeing as this is a network application, there shouldn't be huge
problems unless a service is doing many complicated things that would cause it
to eat CPU.

Example of operation:
 - WebSocketServer running on port 12345 of the host machine
 - User requests ws://localhost:12345/foo/bar/
 	- WebSocketServer processes the directory and begins looking in its
 	  service tree for a process named foo->bar->ws_service.py. If the service
 	  isn't found, it looks in the physical directory and attempts to include
 	  the ws_service.py file in that directory. If it cannot, a 404 is issued.
 	  Additionally, if file doesn't contain a class Service, a 500 is issued. If
 	  the service is found and started, the WebSocketServer performs a handshake
 	  and passes the incoming socket off to the Service class
 - User requests ws://localhost:12345/foo/bar
 	- Same as above except the server will look for foo->bar.py to find the
 	  Service class 

A service must implement the Services.Service class which is in the form of a
threading.thread. The class must be named Service. The main method for
the service should reside in the run() method. Client sockets are sent as a
tuple along the Services.Service.clientConnQueue which is a Queue.Queue. The
first index of the tuple is the socket and the second index is the address
tuple. When the client is received by a service it is ready for data since the
WebSocketServer class which accepts the connection performs handshakes and
rejects any clients that do not give correct handshakes.

Since a service may have any number of clients connected at a time for long
periods of time, the use of threads on a per-client basis is discouraged.
Resources would quickly be eaten away if 10 services had 1000 clients each and
each client ran its own thread. The end user is encouraged to figure out
different ways of managing clients. One way is to use the provided WebSocketClient
class. An example follows:
